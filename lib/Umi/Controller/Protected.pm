# -*- mode: cperl; eval: (follow-mode 1); -*-

package Umi::Controller::Protected;

use Mojo::Base 'Mojolicious::Controller', -signatures;
use Mojo::Util qw(b64_encode dumper trim);
use Mojo::JSON qw(decode_json encode_json to_json);

use Mojolicious::Validator;

use IO::Compress::Gzip qw(gzip $GzipError);
use POSIX qw(strftime);
use Encode qw(decode_utf8);
use Net::LDAP::Constant qw(
			    LDAP_SUCCESS
			    LDAP_PROTOCOL_ERROR
			    LDAP_NO_SUCH_OBJECT
			    LDAP_INVALID_DN_SYNTAX
			    LDAP_INSUFFICIENT_ACCESS
			    LDAP_CONTROL_SORTRESULT
			 );
use Umi::Ldap;

sub homepage ($self) {
  if ($self->session('debug')) {
    $self->stash( debug => $self->session('debug') );
    delete $self->session->{debug};
  }
  $self->render( template => 'protected/home' );
}

sub other ($self) { $self->render(template => 'protected/other'); }

sub manage_chi ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);

  my $command = $p->{command} // 'remove';

   if ( $command eq 'remove' ) {
     $self->chi('fs')->clear;
   }

  return $self->render(template => 'protected/home');
}

sub delete ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $auth = $self->h_is_authorized($p->{delete_dn});
  $self->h_log($auth);
  return $self->render(template => 'not_allowed',
		       debug => { warn => ['attempt to delete dn: ' . $p->{delete_dn}]})
    unless $auth;
  my $msg = $ldap->delete($p->{delete_dn},
			  exists $p->{delete_recursive} && $p->{delete_recursive} eq 'on' ? 1 : 0);
  $self->session( debug => $msg );

  ### alas, this redirect by nature performs a GET request
  return $self
    ->redirect_to($self->url_for('search_common')
		  ->query( search_base_case => $p->{search_base_case},
			   search_filter => $p->{search_filter},
			   ldap_subtree => $p->{ldap_subtree} )
		 );
}

=head2 fire

steps to do on employee firing

=cut

sub fire ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);

  return $self->render(template => 'protected/home') unless $p->{fire_dn};

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $search_arg = { base => $p->{fire_dn},
		     scope => 'sub',
		     attrs => [] };
  # $self->h_log($search_arg);
  my $search = $ldap->search( $search_arg );
  $self->h_log( $self->h_ldap_err($search, $search_arg) ) if $search->code;

  my ($ldif, $root_e);
  foreach ($search->entries) {
    $root_e = $_ if $_->dn eq $p->{fire_dn};
    $ldif .= $_->ldif;
  }

  $ldif = sprintf("### Generated by %s %s on %s\n### description: %s\n\n%s",
		  $self->session('user_obj')->{givenname},
		  $self->session('user_obj')->{sn},
		  strftime("%F %T", localtime),
		  length($p->{description}) ? $p->{description} : '',
		  $ldif);

  # $self->h_log($ldif);

  my $ldif_gz;
  # Compress the data
  gzip \$ldif => \$ldif_gz
    or die "ERROR: gzip failed: $GzipError\n";

  my $ldif_gz_b64 = b64_encode $ldif_gz;

  # $self->h_log($ldif_gz_b64);

  my $aaa = $root_e->get_value('objectClass',asref => 1);
  $self->h_log($aaa);
  my $is_objectClass = grep { $_ eq 'umiUser' } @$aaa;
  $self->h_log($is_objectClass);
  my ($changes, $add, $replace);
  if ( $root_e->exists('umiUserBackup') ) {
      push @$replace, umiUserBackup => $ldif_gz_b64;
      push @$changes, replace => $replace;
  } elsif ( $is_objectClass ) {
      push @$add, umiUserBackup => $ldif_gz_b64;
      push @$changes, add => $add;
  } else {
      push @$add, objectClass => 'umiUser', umiUserBackup => $ldif_gz_b64;
      push @$changes, add => $add;
  }

  push @$replace, gidNumber => $self->{app}->{cfg}->{ldap}->{defaults}->{group}->{blocked}->{gidnumber};
  push @$replace, userPassword => '!' . $root_e->get_value('userPassword') if $root_e->exists('userPassword');

  push @$changes, replace => $replace;

  # $self->h_log($changes);
  my $msg = $ldap->modify($p->{fire_dn}, $changes);
  $self->h_log($msg);
  if ( $msg->{status} eq 'ok' ) {
    $self->session(debug => {$msg->{status} => [ $msg->{message} ]});

    $msg = $ldap->delete($p->{fire_dn}, 1, 'children');
    $self->session( debug => $msg );

    ### alas, this redirect by nature performs a GET request
    return $self
      ->redirect_to($self->url_for('search_common')
		    ->query( search_base_case => $p->{search_base_case},
			     search_filter => $p->{search_filter},
			     ldap_subtree => $p->{ldap_subtree} )
		   );
  }

}

sub ldif_import ($self) {
  my $p = $self->req->params->to_hash;
  # $self->h_log($p);
  my $uploads = $self->req->uploads;
  # $self->h_log($uploads);
  $p->{file} = $uploads->[0]->slurp if @$uploads;

  my $v = $self->validation;
  return $self->render(template => 'protected/tool/ldif-import') unless $v->has_data;

  my ( $ldif, $err );
  $ldif->{ldif} = $p->{ldif} if defined $p->{ldif} && $p->{ldif} ne '';
  $ldif->{file} = $p->{file} if defined $p->{file};
  # $self->h_log($ldif);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $res = $ldap->ldif_read(defined $p->{file} && $p->{file} ne '' ? $p->{file} : $p->{ldif} );

  $self->stash(debug => $res->{debug});

  # $self->h_log($key);
  return $self->render(template => 'protected/tool/ldif-import',
		       # layout => undef
		      );
}

sub ldif_export ($self) {
  my $v = $self->validation;
  return $self->render(template => 'protected/tool/ldif-export') unless $v->has_data;

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $p = $self->req->params->to_hash;
  # $self->h_log($p);
  $p->{dn} =~ s/ //g;
  my $search_arg = { base => $p->{dn}, scope => $p->{scope} };
  $search_arg->{attrs} = [] if !exists $p->{sysinfo};
  # $self->h_log($search_arg);
  my $search = $ldap->search( $search_arg );
  $self->h_log( $self->h_ldap_err($search, $search_arg) ) if $search->code;

  my $ldif;
  $ldif .= $_->ldif foreach ($search->entries);

  # $self->h_log($ldif);
  $self->stash(ldif_export_params => $p, ldif => $ldif);
  return $self->render(template => 'protected/tool/ldif-export'); #, layout => undef);
}

sub ldif_clone ($self) {
  my $p = $self->req->params->to_hash;

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $ldif;
  if ( ! exists $p->{ldif} ) {
    my $search_arg = { base => $p->{dn_to_clone}, scope => 'base', attrs => [] };
    my $search = $ldap->search( $search_arg );
    $self->h_log( $self->h_ldap_err($search, $search_arg) ) if $search->code;
    $ldif .= $_->ldif foreach ($search->entry);
  } else {
    my $res = $ldap->ldif_read( $p->{ldif} );
    $self->stash(debug => $res->{debug});
  }

  $self->stash(ldif => exists $p->{ldif} ? $p->{ldif} : $ldif,
	       dn_to_clone => $p->{dn_to_clone});
  return $self->render( template => 'protected/tool/ldif-clone', );
}

sub sysinfo ($self) {
  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $schema = $ldap->schema;
  my %oc = map { $_->{name} => $_ } $schema->all_objectclasses;
  my %aa = map { $_->{name} => $_ } $schema->all_attributes;
  my %as = map { $_->{name} => $_ } $schema->all_syntaxes;
  my %s;
  $s{all_objectclasses} = \%oc;
  $s{all_attributes} = \%aa;
  $s{all_syntaxes} = \%as;

  my $chi;
  @{$chi->{keys}} = $self->chi('fs')->get_keys;
  @{$chi->{namespaces}} = $self->chi('fs')->get_namespaces;

  return $self->render( template => 'protected/tool/sysinfo',
			schema => encode_json(\%s),
			chi => $chi,
			); # layout => undef);
}

sub pwdgen ($self) {
  my $cf = $self->{app}->{cfg}->{tool}->{pwdgen}->{xk};
  my $par = $self->req->params->to_hash;
  $self->h_log($par);

  $par->{pwd_chg_rdn} = $self->h_get_rdn_val($par->{pwd_chg_dn}) if ! exists $par->{pwd_chg_rdn};
  if ( ! exists $par->{pwd_chg_svc} && $par->{pwd_chg_dn} =~ /authorizedService=/ ) {
    my $re = qr/^.*,authorizedService=([^,]+),uid=.*,$self->{app}->{cfg}->{ldap}->{base}->{acc_root}$/i;
    $par->{pwd_chg_svc} = $1 if $par->{pwd_chg_dn} =~ /$re/;
  }

  $self->stash({ pwdgen_params => $par }) if exists $par->{pwd_chg_dn};

  return $self->render( template => 'protected/tool/pwdgen' ) unless exists $par->{pwd_vrf} || exists $par->{pwd_alg};

  my $v = $self->validation;

  if ( ! exists $par->{pwd_vrf} ) {
    $v->error( xk_num_words => ['can not be empty']) if ! exists $par->{xk_num_words} || ( exists $par->{xk_num_words} && length($par->{xk_num_words}) < 1 );

    $v->error( xk_separator_character_char => ['can not be empty'] )
      if exists $par->{xk_separator_character} && $par->{xk_separator_character} eq 'sep-char'
      && exists $par->{xk_separator_character_char} && $par->{xk_separator_character_char} eq '';

    $v->error( xk_separator_alphabet => ['can not be empty'])
      if exists $par->{xk_separator_character} && $par->{xk_separator_character} eq 'sep-random'
      && exists $par->{xk_separator_alphabet} && length($par->{xk_separator_alphabet}) < 1;

    $v->error( xk_padding_digits_before => ['can not be empty']) if exists $par->{xk_padding_digits_before} && length($par->{xk_padding_digits_before}) < 1;
    $v->error( xk_padding_digits_after => ['can not be empty']) if exists $par->{xk_padding_digits_after} && length($par->{xk_padding_digits_after}) < 1;

    $v->error( xk_padding_characters_before => ['can not be empty'])
      if exists $par->{xk_padding_type} && $par->{xk_padding_type} eq 'pad-fixed'
      && exists $par->{xk_padding_characters_before} && length($par->{xk_padding_characters_before}) < 1;
    $v->error( xk_padding_characters_after => ['can not be empty'])
      if exists $par->{xk_padding_type} && $par->{xk_padding_type} eq 'pad-fixed'
      && exists $par->{xk_padding_characters_after} && length($par->{xk_padding_characters_after}) < 1;

    $v->error( xk_padding_character_char => ['can not be empty'])
      if exists $par->{xk_padding_character} && $par->{xk_padding_character} eq 'pch-character'
      && exists $par->{xk_padding_character_char} && length($par->{xk_padding_character_char}) < 1;
    $v->error( xk_padding_alphabet => ['can not be empty'])
      if exists $par->{xk_padding_character} && $par->{xk_padding_character} eq 'pch-random'
      && exists $par->{xk_padding_alphabet} && length($par->{xk_padding_alphabet}) < 1;

    $v->error( xk_pad_to_length => ['can not be empty'])
      if exists $par->{xk_padding_type} && $par->{xk_padding_type} eq 'pad-adaptive'
      && exists $par->{xk_pad_to_length} && length($par->{xk_pad_to_length}) < 1;
  }

  my $pwdgen;
  if ( ! $v->has_error ) {

    # $self->h_log($par);
    $pwdgen = $self->h_pwdgen($par);
    # $self->h_log($pwdgen);
    if ( exists $pwdgen->{error} ) {
      $self->stash({debug => { error => [ $pwdgen->{error} ]}});
    } else {
      my ($ldap, $search, $search_arg, $pwd_from_ldap, $match, $mesg);
      if (exists $par->{pwd_chg_dn}) {
	$ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
	if (exists $par->{pwd_vrf}) {
	  ### password verification against LDAP
	  $search_arg = { base => $par->{pwd_chg_dn}, attrs => ['userPassword'] };
	  $search = $ldap->search( $search_arg );
	  $self->h_log( $self->h_ldap_err($search, $search_arg) ) if $search->code;
	  $pwd_from_ldap = $search->entry->get_value('userPassword');
	  $self->h_log($pwd_from_ldap);
	  $match = $pwd_from_ldap eq $pwdgen->{ssha} ? 1 : 0;
	  $self->stash({debug => { $match ? 'ok' : 'warn' => [ sprintf('provided password %s %s',
								       $pwdgen->{clear},
								       $match ? 'match' : 'does not match') ]
				 }});
	} else {
	  ### userPassword attribute modification
	  $mesg = $ldap->modify( $par->{pwd_chg_dn}, [ replace => [ 'userPassword' => $pwdgen->{ssha}, ], ] );
	  $self->h_log($mesg );
	  # $self->h_log( $self->{app}->h_ldap_err($mesg, undef) ) if $mesg->code;
	  $self->stash({debug =>
			{ $mesg->{status} => [ $mesg->{message},
					       sprintf('new password: <span class="badge text-bg-secondary user-select-all">%s</span>',
						       $pwdgen->{clear}) ]
			}});
	}
      } else {
	$self->stash({debug =>
		      { $pwdgen->{stats}->{passwords_generated} > 0
			? 'ok' : 'warn' => [ sprintf('new password: <span class="badge text-bg-secondary user-select-all">%s</span>',
						     $pwdgen->{clear}) ]
		      }});
      }
    }
  }
  return $self->render(template => 'protected/tool/pwdgen',
		       pwdgen_params => $par,
		       pwdgen => $pwdgen,
		       ); # layout => undef);
}

sub qrcode ($self) {
  my $v = $self->validation;
  return $self->render(template => 'protected/tool/qrcode') unless $v->has_data;

  my $par = $self->req->params->to_hash;
  $self->stash(qrcode_params => $par);
  return $self->render(template => 'protected/tool/qrcode' => qrcode => $self->h_qrcode($par)); # , layout => undef);
}

sub keygen_ssh ($self) {
  my $v = $self->validation;
  return $self->render(template => 'protected/tool/keygen/ssh') unless $v->has_data;

  my $par = $self->req->params->to_hash;
  $self->stash(kg_ssh_params => $par);

  my $k = $self->h_keygen_ssh($par);
  $self->stash(debug => $k->{debug});

  # $self->h_log($k);
  return $self->render(template => 'protected/tool/keygen/ssh',
		       key => {
			       ssh => $k,
			       name => { real => 'name will be here',
					 email => 'email will be here' }
			      },
		       # layout => undef
		      );
}

sub keygen_gpg ($self) {
  my $par = $self->req->params->to_hash;
  # $self->h_log($par);
  my $v = $self->validation;
  return $self->render(template => 'protected/tool/keygen/gpg') unless $v->has_data;

  $par->{name} = {
		  real => sprintf("%s %s", $self->session->{user_obj}->{givenname}, $self->session->{user_obj}->{sn}),
		  email => $self->session->{user_obj}->{mail}
		 };
  my $k = $self->h_keygen_gpg($par);
  $self->stash(debug => $k->{debug});

  # $self->h_log($k);

  return $self->render(template => 'protected/tool/keygen/gpg',
		       key => $k,
		       # layout => undef
		      );
}


=head2 keyimport_gpg

Import GPG from file or string

=cut

sub keyimport_gpg ($self) {
  my $par = $self->req->params->to_hash;
  # $self->h_log($par);
  my $uploads = $self->req->uploads;
  # $self->h_log($uploads);
  $par->{key_file} = $uploads->[0]->slurp if @$uploads;

  my $v = $self->validation;
  return $self->render(template => 'protected/tool/keyimport/gpg') unless $v->has_data;

  my ( $key, $err );
  $key->{import}->{key_text} = $par->{key_text} if defined $par->{key_text} && $par->{key_text} ne '';
  $key->{import}->{key_file} = $par->{key_file} if defined $par->{key_file};
  # $self->h_log($key);

  $key->{gpg} = $self->h_keygen_gpg({ import => $key->{import}, });
  $self->stash(debug => $key->{gpg}->{debug}) if exists $key->{gpg}->{debug};

  if ( !exists $key->{gpg}->{debug}->{error} ) {
    my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
    my ($add_dn, $add_arg);
    $add_dn = sprintf("pgpCertID=%s,%s",
		      $key->{gpg}->{send_key}->{pgpCertID},
		      $self->{app}->{cfg}->{ldap}->{base}->{pgp});
    @{$add_arg} = map { $_ => $key->{gpg}->{send_key}->{$_} } keys %{$key->{gpg}->{send_key}};
    my $a = $ldap->add( $add_dn, $key->{gpg}->{send_key} );
    $self->h_log( $a->{message} ) if $a->{status} eq 'error';
    $self->stash(debug => {$a->{status} => [ $a->{message} ]});
  }

  # $self->h_log($key);
  return $self->render(template => 'protected/tool/keyimport/gpg',
		       key => $key,
		       # layout => undef
		      );
}

=head1 modify

method to modify whole oject or some definite attribute (if parameter
attr_to_modify exists)

=cut

sub modify ($self) {
  my $p = $self->req->params->to_hash;

  return $self->render(template => 'protected/home') unless exists $p->{dn_to_modify};

  my $uploads = $self->req->uploads;
  my ($crt, %debug, $service);
  # $self->h_log($p);
  # $self->h_log($uploads);
  if ( @$uploads ) {
    if ( exists $p->{authorizedService} ) {
      ($service) = $p->{authorizedService} =~ /([^@]+)/;
    }

    foreach ( @$uploads ) {
      # $self->h_log($_);
      my $n = $_->name;
      $n =~ s/_binary/;binary/;
      $p->{$n} = $_->slurp;

      if ( $n eq 'userCertificate;binary' ) {
	$crt = $self->h_cert_info({ cert => $p->{$n}, ts => "%Y%m%d%H%M%S", });
	$p->{umiUserCertificateSn}        = '' . $crt->{'S/N'},
	$p->{umiUserCertificateNotBefore} = '' . $crt->{'Not Before'},
	$p->{umiUserCertificateNotAfter}  = '' . $crt->{'Not After'},
	$p->{umiUserCertificateSubject}   = '' . $crt->{Subject},
	$p->{umiUserCertificateIssuer}    = '' . $crt->{Issuer};
	$p->{cn} = $crt->{CN}
	  if exists $p->{cn} && $self->{app}->{cfg}->{ldap}->{authorizedService}->{$service}->{rdn} ne 'cn';
	# FIX ?? this relates to the services like `dot1x-eap-tls`
	# and not necesseraly should be equal to certificate CN
	# need to check, wheather userPassword was provided to not overwrite it
	$p->{userPassword} = $crt->{CN} if exists $p->{userPassword};
      } elsif ( $n eq 'jpegPhoto' && $p->{$n} ne '' ) {
	$p->{$n} = $self->h_img_resize( $p->{$n}, $_->size );
      }
    }
  }
  # $self->h_log($p);

  my $attr_to_add = exists $p->{attr_to_add} && $p->{attr_to_add} ne '' ? $p->{attr_to_add} : undef;
  my $dn_to_modify = $p->{dn_to_modify};
  my $attr_to_ignore;
  my $rdn = $self->h_get_rdn($dn_to_modify);
  %{$attr_to_ignore} = map {$_ => 1}
    @{[qw(dn_to_modify attr_to_add attr_unused modifyTimestamp modifiersName creatorsName createTimestamp)]};
  $attr_to_ignore->{$rdn} = 1;

  ##############################################
  # check for permissions to modify the object #
  ##############################################
  my $auth = $self->h_is_authorized($p->{dn_to_modify});
  # $self->h_log($auth);
  return $self->render(template => 'not_allowed',
		       debug => { warn => ['attempt to modify dn: ' . $p->{dn_to_modify}]}) unless $auth;

  my $v = $self->validation;
  return $self->render(template => 'protected/tool/modify') unless $v->has_data;
  # return $self->render(template => 'protected/tool/modify') unless %$p;

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $search_arg = { base => $p->{dn_to_modify}, scope => 'base' };
  $search_arg->{attrs} = defined $attr_to_add ? [$attr_to_add] : [];
  # $self->h_log( $search_arg );
  my $s = $ldap->search( $search_arg );
  if ( $s->code ) {
    $self->h_log( $self->h_ldap_err($s, $search_arg) );
    return $self->render(template => 'protected/home',
			 debug => {
				   status => 'error',
				   message => $ldap->err($s, 0, $p->{dn_to_modify})->{html}
				  });
    # $self->h_log( $s->as_struct );
  }

  my $e_orig = $self->h_modify_get_e_orig($s, $rdn, $p);

  # push @{$p->{objectClass}}, 'umiUser'
  #   if !grep { $_ eq 'umiUser' } @{$p->{objectClass}};

  # $self->h_log($p);
  # $self->h_log($e_orig);

  # `UNUSED ATTRIBUTES` select element
  my ($schema, %oc, %aa, %as, @attr_unused);
  if ( ! defined $attr_to_add ) {
    $schema = $ldap->schema;
    %oc = map { $_->{name} => $_ } $schema->all_objectclasses;
    %aa = map { $_->{name} => $_ } $schema->all_attributes;
    %as = map { $_->{name} => $_ } $schema->all_syntaxes;
    @attr_unused = $self->h_attr_unused($s->entry, \%oc);
  }
  # NEED to re-check what it is for :(
  $self->stash({ attr_to_add => $p->{attr_to_add} })
    if defined $attr_to_add;

  my ($add, $delete, $replace, $changes);
  if ( keys %$p < 3 && !exists $p->{add_objectClass} ) {
    # here we've just clicked, search result  menu `modify` button
    $self->h_log('~~~~~-> MODIFY [' . $self->req->method . ']: FIRST RUN (search result menu choosen)');
  } elsif (exists $p->{add_objectClass}) {
    # new objectClass addition is chosen
    $self->h_log('~~~~~-> MODIFY [' . $self->req->method . ']: ADD OBJECTCLASS');
    $self->h_log($p);
    foreach (keys(%$p)) {
      next if $_ !~ /^add_/;
      push @$add, substr($_,4) => $p->{$_};
    }
    push @$changes, add => $add;
    if ($changes) {
      $self->h_log($changes);
      my $msg = $ldap->modify($s->entry->dn, $changes);
      push @{$debug{$msg->{status}}}, $msg->{message};
    }
  } else {
    # form modification made
    $self->h_log('~~~~~-> MODIFY [' . $self->req->method . ']: IS FORM CHANGED?');
    delete $p->{$_} foreach (keys %{$attr_to_ignore});
    foreach (keys %$p) {
      delete $p->{$_} if $p->{$_} eq '';
    }

    my $diff = $self->h_hash_diff( $e_orig, $p);
    #$self->h_log($diff);
    if ( %{$diff->{added}} ) {
      push @$add, $_ => $diff->{added}->{$_} foreach (keys(%{$diff->{added}}));
      push @$changes, add => $add;
    }
    if ( %{$diff->{removed}} ) {
      push @$delete, $_ => [] foreach (keys(%{$diff->{removed}}));
      push @$changes, delete => $delete;
    }
    if ( %{$diff->{changed}} ) {
      push @$replace, $_ => $diff->{changed}->{$_}->{new} foreach (keys(%{$diff->{changed}}));
      push @$changes, replace => $replace;
    }

    if ($changes) {
      # $self->h_log($changes);
      my $msg = $ldap->modify($s->entry->dn, $changes);
      push @{$debug{$msg->{status}}}, $msg->{message};

      if ( exists $p->{'userCertificate;binary'} ) {
	# ($service) = $p->{authorizedService} =~ /([^@]+)/;
	# $self->h_log($service);
	my $moddn = $self->{app}->{cfg}->{ldap}->{authorizedService}->{$service}->{rdn} . '=' . $crt->{CN};
	$msg = $ldap->moddn({ src_dn => $s->entry->dn, newrdn => $moddn, });
	# $self->h_log($msg);
	push @{$debug{$msg->{status}}}, $msg->{message};
	my $modified_dn = $s->entry->dn;
	$modified_dn =~ s/^(.*?=)[^,]+(,.*)/$1$crt->{CN}$2/;
	# $self->h_log(\%debug);
	return $self->session(debug => \%debug)->redirect_to($self->url_for('modify')
							   ->query( dn_to_modify => $modified_dn ));
      }

    }
  }

  $search_arg->{base} = $dn_to_modify;
  $s = $ldap->search( $search_arg );
  $self->{app}->h_log( $self->{app}->h_ldap_err($s, $search_arg) ) if $s->code;
  @attr_unused = $self->h_attr_unused($s->entry, \%oc) if ! defined $attr_to_add;

  $self->stash(
	       debug => \%debug,
	       entry => $s->entry,
	       aa => \%aa, as => \%as, oc => \%oc,
	       attr_unused => \@attr_unused,
	       attr_to_add => $attr_to_add,
	       attr_to_ignore => $attr_to_ignore,
	       #dn_to_modify => $attr_to_add
	      );

  return $self->render(template => 'protected/tool/modify'); #, layout => undef);
}

sub profile ($self) {
  my $p = $self->req->params->to_hash;
  my $reqpath = $self->req->url->to_abs->path;
  my ($uid, $filter, $chi, $chi_key, $chi_template, $to_chi);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  my $contextCSN = $ldap->get_contextCSN;
  if ( $reqpath =~ /^\/audit\/.*$/ ) {
    $chi_key = 'profile_audit';
    $chi_template = 'protected/audit/users';
    $uid = 'all';
  } else {
    $uid = $p->{uid} // $self->stash->{uid} // '';
    $chi_template = 'protected/profile';
  }

  ### PROFILE TO GET:
  if ($uid eq 'all') {
    $chi_key = 'profile_all' if ! defined $chi_key;
    $filter = '(uid=*)';
    ### $filter = '(uid=al*)';
  } elsif ($uid eq 'disabled') {
    $chi_key = 'profile_disabled';
    $filter = sprintf("(&(uid=*)(gidNumber=%s))",
		      $self->{app}->{cfg}->{ldap}->{defaults}->{group}->{blocked}->{gidnumber});
  } elsif ($uid eq 'active') {
    $chi_key = 'profile_active';
    $filter = sprintf("(&(uid=*)(!(gidNumber=%s)))",
		      $self->{app}->{cfg}->{ldap}->{defaults}->{group}->{blocked}->{gidnumber});
  } elsif ($uid ne '') {
    $chi_key = 'nokey';
    $filter = sprintf("(|(uid=%s)(givenName=%s)(sn=%s))", $uid, $uid, $uid);
  } else {
    $chi_key = 'nokey';
    $filter = sprintf("(uid=%s)", $self->session('uid'));
  }

  $chi = $self->chi('fs')->get($chi_key);
  if ( $chi ) {
    if ($chi->{contextCSN} ge $contextCSN) {
      $self->h_log($chi->{contextCSN});
      $self->h_log($contextCSN);
      $self->stash(
		   contextCSN => $contextCSN,
		   profiled_user => $chi->{profiled_user},
		   groups => $chi->{groups},
		   modifiersname => $chi->{modifiersname},
		   pgp => $chi->{pgp},
		   projects => $chi->{projects},
		   search_base_case => $chi->{search_base_case},
		   server_alive => $chi->{server_alive},
		   servers => $chi->{servers},
		   servers_alive_list => $chi->{servers_alive_list},
		   services => $chi->{services},
		  );
      if ( exists $p->{as_json} && $p->{as_json} eq 'yes' ) {
	return $self->render(json => $chi);
      } else {
	return $self->render(template => $chi_template);
      }
    } else {
      $self->h_log($chi->{contextCSN});
      $self->h_log($contextCSN);
      $self->chi('fs')->remove($chi_key);
    }
  }

  my $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{acc_root},
		     filter => $filter,
		     scope => 'one' };
  $search_arg->{attrs} = [qw(
			      gidNumber
			      givenName
			      mail
			      modifiersName
			      sn
			      uid
			      umiUserDateOfBirth
			      umiUserDateOfEmployment
			      umiUserDateOfTermination
			   )]
    if $reqpath =~ /^\/audit\/.*$/;

  # $self->{app}->h_log( $search_arg);
  my $search = $ldap->search( $search_arg );
  $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  my $profiled_user = $search->as_struct;
  # $self->h_log($profiled_user);

  my ( $cf_svc, $groups, $k, $kk, $modifiersname, $pr, $pgp, $pgp_e, $projects, $server_names, $server_alive, $servers_alive_list, $servers, $service, $svc, $svc_details, $svc_msg, $v, $vv, );
  while (($k, $v) = each %$profiled_user) {
    ### name of the last who modified this user root object
    $search_arg = { base => $v->{modifiersname}->[0], scope => 'base', attrs => ['gecos', 'uid'] };
    $search = $ldap->search( $search_arg );
    $modifiersname->{$k} = $search->as_struct->{$v->{modifiersname}->[0]};

    ### only admins and coadmins need this info
    if ( $self->is_role('admin,coadmin,hr', {cmp => 'or'}) || $reqpath eq '/audit/users') {
      ### GROUPS: list of all groups user is a member of
      $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{group},
		      filter => '(memberUid=' . $v->{uid}->[0] . ')',
		      attrs => ['cn'] };
      $search = $ldap->search( $search_arg );
      my $g = $search->as_struct;
      push @{$groups->{$k}}, $vv->{cn}->[0] while (($kk, $vv) = each %$g);

      ### SERVERS: list of all servers available for the user
      $search_arg = { base => 'ou=access,' . $self->{app}->{cfg}->{ldap}->{base}->{netgroup},
		      filter => '(nisNetgroupTriple=*,' . $v->{uid}->[0] . ',*)',
		      attrs => ['nisNetgroupTriple'] };
      $search = $ldap->search( $search_arg );
      $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
      my $netgroups = $search->as_struct;
      my $tuple;
      while (my ($kk, $vv) = each %$netgroups) {
	foreach (@{$vv->{nisnetgrouptriple}}) {
	  @$tuple = split(/,/, substr($_, 1, -1));
	  push @{$server_names->{$k}}, sprintf("%s.%s", $tuple->[0], $tuple->[2]);
	}
      }
      @{$servers->{$k}} = do {
	my %seen;
	sort grep { !$seen{$_}++ } @{$server_names->{$k}};
      };
      foreach (@{$servers->{$k}}) {
	$search_arg = { base => 'cn=' . $_ . ',' . $self->{app}->{cfg}->{ldap}->{base}->{machines},
			attrs => ['cn'] };
	$search = $ldap->search( $search_arg );
	$self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != 32;
	$server_alive->{$k}->{$_} = $search->count;
	$servers_alive_list->{$_} = $search->count;
      }
      # $self->h_log($servers);
    }

    ### SERVICES
    $search_arg = { base => $k,
		    scope => 'one',
		    sizelimit => 0,
		    filter => 'authorizedService=*',
		    attrs => [ 'authorizedService'],};
    $search = $ldap->search( $search_arg );
    $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != 32;

    foreach $svc (@{[$search->sorted( 'authorizedService' )]}) {
      $svc_msg = $ldap->search( { base => $svc->dn, scope => 'children', });
      $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != 32;
      next if ! $svc_msg->count;

      $cf_svc = $self->{app}->{cfg}->{ldap}->{authorizedService}->{(split('@', $svc->get_value('authorizedService')))[0]};

      $svc_details = {
		      branch_dn => $svc->dn,
		      # authorizedService => $svc->get_value('authorizedService'),
		      auth => $cf_svc->{auth},
		      icon => $cf_svc->{icon},
		      descr => $cf_svc->{descr},
		     };

      foreach my $e (@{[$svc_msg->sorted( 'authorizedService' )]}) {
	# !!! WARNING may there be something except `cn` and `uid`?
	# $svc_details->{leaf}->{$e->dn} = $e->get_value('uid') // $e->get_value('cn');
	%{$svc_details->{obj}->{$e->dn}} =
	  map { $_ => $e->get_value($_, asref => 1) } $e->attributes;
      }
      $service->{$k}->{$svc->get_value('authorizedService')} = $svc_details;
      undef $svc_details;
    }
    # $self->h_log($service);

    ### GPG
    $filter = '(|';
    $filter .= sprintf("(pgpUserID=*%s*)", $v->{sn}->[0]);
    $filter .= sprintf("(pgpUserID=*%s*)", $v->{mail}->[0]) if exists $v->{mail};
    $filter .= ')';
    $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{pgp}, filter => $filter };
    $search = $ldap->search( $search_arg );
    $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != 32;
    $pgp_e = $search->as_struct;
    foreach (keys %$pgp_e) {
      $pgp->{$k}->{$pgp_e->{$_}->{pgpuserid}->[0]} =
	{
	 keyid => $pgp_e->{$_}->{pgpkeyid}->[0],
	 key   => $pgp_e->{$_}->{pgpkey}->[0],
	};
    }
    #$self->h_log($pgp);

    ### PROJECTS: list of all projects user is a member of
    $search_arg = { base => 'ou=group,' . $self->{app}->{cfg}->{ldap}->{base}->{project},
		    filter => '(memberUid=' . $v->{uid}->[0] . ')',
		    attrs => ['cn'] };
    $search = $ldap->search( $search_arg );
    $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
    $pr = $search->as_struct;
    @{$projects->{$k}} = sort map { $pr->{$_}->{cn}->[0] =~ s/_/:/r } keys(%$pr);
  }

  $to_chi = {
	     contextCSN => $contextCSN,
	     profiled_user => $profiled_user,
	     groups => $groups,
	     pgp => $pgp,
	     servers => $servers,
	     services => $service,
	     server_alive => $server_alive,
	     servers_alive_list => $servers_alive_list,
	     search_base_case => $self->{app}->{cfg}->{ldap}->{base}->{machines},
	     projects => $projects,
	     modifiersname => $modifiersname,
	    };

  #$self->chi('fs')->set( profile_audit => $to_chi if $reqpath =~ /^\/audit\/.*$/;
  #$self->chi('fs')->set( profile_all => $to_chi if $uid eq 'all';
  $self->chi('fs')->set( $chi_key => $to_chi);

  $self->stash(
	       profiled_user => $profiled_user,
	       groups => $groups,
	       pgp => $pgp,
	       servers => $servers,
	       services => $service,
	       server_alive => $server_alive,
	       servers_alive_list => $servers_alive_list,
	       search_base_case => $self->{app}->{cfg}->{ldap}->{base}->{machines},
	       projects => $projects,
	       modifiersname => $modifiersname,
	      );

  if ( exists $p->{as_json} && $p->{as_json} eq 'yes' ) {
    return $self->render(json => $to_chi);
  } else {
    my $template = $reqpath =~ /^\/audit\/.*/ ? 'protected/audit/users' : 'protected/profile';
    # $self->h_log($template);
    return $self->render(template => $template); #layout => undef);
  }
}

sub profile_new ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);
  $self->stash(profile_new_params => $p);
  my $upload;
  my $uploads = $self->req->uploads;
  # $self->h_log($uploads);
  if ( @$uploads ) {
    %$upload = map { $_->name => $_ } @$uploads;
  }

  my $v = $self->validation;
  return $self->render(template => 'protected/profile/new') unless $v->has_data;

  my $re_name = qr/^\p{Lu}\p{L}*([-']\p{L}+)*[0-9]*$/;
  my $re_date = qr/^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
  $v->required('user_first_name')->like($re_name);
  $v->required('user_last_name')->like($re_name);
  $v->required('title');
  $v->required('umiUserDateOfEmployment')->like($re_date);
  ### $v->required('umiUserDateOfBirth')->like($re_date);
  $v->required('city');
  $v->required('umiUserGender');
  $v->required('umiUserCountryOfResidence');

  $v->error(user_first_name => ['Required, can contain alfanumeric characters and dash, first letter capital']) if $v->error('user_first_name');
  $v->error(user_last_name => ['Required, can contain alfanumeric characters and dash, first letter capital']) if $v->error('user_last_name');

  my $nf = $self->h_translit(lc $p->{user_first_name});
  my $nl = $self->h_translit(lc $p->{user_last_name});
  my $nn = sprintf("%s %s", $self->h_translit($p->{user_first_name}), $self->h_translit($p->{user_last_name}));
  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{acc_root},
		     filter => sprintf("(|(&(givenName=%s)(sn=%s))(uid=%s.%s))",
				       $p->{user_first_name},
				       $p->{user_last_name},
				       $nf,
				       $nl),
		     scope => "one" };
  my $search = $ldap->search( $search_arg );
  $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  $v->error(user_first_name => ['User with such first and last names exists']) if $search->count > 0;
  $v->error(user_last_name  => ['User with such first and last names exists']) if $search->count > 0;

  # my $jpegPhoto_error;
  # if ($upload->{jpegPhoto}->size) {
  #   my $sides = $self->h_img_info($upload->{jpegPhoto}->slurp);
  #   if ( $sides->{width} > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side} ) {
  #     $jpegPhoto_error .= sprintf('File %s width is %s what is bigger than %s px; ',
  #				  $upload->{jpegPhoto}->filename,
  #				  $sides->{width},
  #				  $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side});
  #   } elsif ( $sides->{height} > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side} ) {
  #     $jpegPhoto_error .= sprintf('File %s height is %s what is bigger than %s px; ',
  #				  $upload->{jpegPhoto}->filename,
  #				  $sides->{height},
  #				  $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side});
  #   }
  # }
  # $jpegPhoto_error .= sprintf('File %s is bigget than %s bytes.',
  #			      $upload->{jpegPhoto}->filename,
  #			      $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_size})
  #   if $upload->{jpegPhoto}->size > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_size};

  # $v->error( jpegPhoto => [ $jpegPhoto_error ] ) if defined $jpegPhoto_error;

  if ( ! $v->has_error ) {
    my $attrs = {
		 cn        => $nn,
		 gecos     => $nn,
		 gidNumber => $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{gidNumber}->{onboarding},
		 givenName => $p->{user_first_name},
		 l         => $p->{city},
		 homeDirectory => sprintf("/usr/local/home/%s.%s", $nf, $nl),
		 objectClass   => $self->{app}->{cfg}->{ldap}->{objectClass}->{acc_root},
		 umiUserGender => $p->{umiUserGender},
		 sn            => $p->{user_last_name},
		 title         => $p->{title},
		 uid           => sprintf("%s.%s", $nf, $nl),
		 umiUserCountryOfResidence => $p->{umiUserCountryOfResidence},
		 umiUserDateOfEmployment   => $self->h_ts_to_generalizedTime($p->{umiUserDateOfEmployment}),
		 umiUserDateOfBirth        => $self->h_ts_to_generalizedTime($p->{umiUserDateOfBirth}),
		};

    # $attrs->{jpegPhoto} = $upload->{jpegPhoto}->slurp if $upload->{jpegPhoto}->size > 0;
    $attrs->{jpegPhoto} = $self->h_img_resize( $upload->{jpegPhoto}->slurp ) if $upload->{jpegPhoto}->size > 0;

    my $u = $ldap->last_num;
    if ( $u->[1] ) {
      $self->h_log($u->[1]);
      $attrs->{uidNumber} = undef;
    } else {
      $attrs->{uidNumber} = $u->[0] + 1;
    }

    # $self->h_log($attrs);

    my $msg = $ldap->add(sprintf("uid=%s.%s,%s",
				 $nf,
				 $nl,
				 $self->{app}->{cfg}->{ldap}->{base}->{acc_root}),
			 $attrs);
    $self->stash(debug => {$msg->{status} => [ $msg->{message} ]});
  }

  $self->render(template => 'protected/profile/new');
}

sub profile_modify ($self) {
  my $from_form = $self->req->params->to_hash;
  $self->h_log($from_form);
  my $upload;
  my $uploads = $self->req->uploads;
  # $self->h_log($uploads);
  if ( @$uploads ) {
    %$upload = map { $_->name => $_ } @$uploads;
  }
  $self->h_compact($from_form);

  my $uid = $self->stash->{uid} // $from_form->{uid_to_modify} // '';
  $from_form->{uid_to_modify} = $self->stash->{uid} if exists $self->stash->{uid};
  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{acc_root},
		     filter => '(uid=' . $uid .')',
		     scope => 'one',
		     attrs => [qw(
				   givenName
				   jpegPhoto
				   l
				   sn
				   title
				   umiUserCountryOfResidence
				   umiUserDateOfBirth
				   umiUserDateOfEmployment
				   umiUserDateOfTermination
				   umiUserGender
				)], };
  my $search = $ldap->search( $search_arg );
  $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  my ($from_ldap, $dn, $e);
  if ($search->count) {
    %$from_ldap = map {
      if ( $_ eq 'mail' || $_ eq 'jpegPhoto' ) {
	$_ => $search->entry->get_value($_);
      } else {
	$_ => utf8::is_utf8($search->entry->get_value($_)) ? $search->entry->get_value($_) : decode_utf8($search->entry->get_value($_));
      }
    } $search->entry->attributes;
    $dn = $search->entry->dn;
  }

  $self->stash(from_ldap => $from_ldap);
  $self->stash(from_form => $from_form);

  my $v = $self->validation;
  return $self->render(template => 'protected/profile/modify') unless $v->has_data;

  my $re_name = qr/^\p{Lu}\p{L}*([-']\p{L}+)*[0-9]*$/;
  my $re_date = qr/^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
  $v->required('givenName')->like($re_name);
  $v->required('sn')->like($re_name);
  $v->required('title');
  $v->required('umiUserDateOfEmployment')->like($re_date);
  ### $v->required('umiUserDateOfBirth')->like($re_date);
  $v->required('umiUserGender');
  $v->required('l');
  $v->required('umiUserCountryOfResidence');
  $v->error( givenName => ['UTF-8 and - characters only'] ) if $v->error('givenName');
  $v->error( sn        => ['UTF-8 and - characters only'] ) if $v->error('sn');
  $v->error( title     => ['UTF-8 and - characters only'] ) if $v->error('title');

  # my $jpegPhoto_error;
  # if ($upload->{jpegPhoto}->size) {
  #   my $sides = $self->h_img_info($upload->{jpegPhoto}->slurp);
  #   if ( $sides->{width} > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side} ) {
  #     $jpegPhoto_error .= sprintf('File %s width is %s what is bigger than %s px; ',
  #				  $upload->{jpegPhoto}->filename,
  #				  $sides->{width},
  #				  $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side});
  #   } elsif ( $sides->{height} > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side} ) {
  #     $jpegPhoto_error .= sprintf('File %s height is %s what is bigger than %s px; ',
  #				  $upload->{jpegPhoto}->filename,
  #				  $sides->{height},
  #				  $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_side});
  #   }
  # }
  # $jpegPhoto_error .= sprintf('File %s is bigget than %s bytes.',
  #			      $upload->{jpegPhoto}->filename,
  #			      $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_size})
  #   if $upload->{jpegPhoto}->size > $self->{app}->{cfg}->{ldap}->{defaults}->{attr}->{jpegPhoto}->{max_size};

  # $v->error( jpegPhoto => [ $jpegPhoto_error ] ) if defined $jpegPhoto_error;

  if ( ! $v->has_error ) {
    # $self->h_log($from_form);
    $from_form->{jpegPhoto} = $upload->{jpegPhoto}->slurp if $upload->{jpegPhoto}->size > 0;

    $self->stash( debug_status => 'debug',
		  debug_message => sprintf("<pre>%s</pre>",
					   dumper {
					     from_form => $from_form,
					       uid => $self->stash->{uid},
					       from_ldap => $self->stash->{from_ldap}
					     })
		);

    my ($tmp_k, $tmp_v) = ('uid_to_modify', $from_form->{uid_to_modify});

    my %l = %$from_ldap;
    delete $l{jpegPhoto} if exists $l{jpegPhoto};
    my %f = %$from_form;
    delete $f{jpegPhoto} if exists $f{jpegPhoto};
    delete $f{uid_to_modify};
    # $f{umiUserDateOfBirth} .= 'Z' if exists $f{umiUserDateOfBirth} && $f{umiUserDateOfBirth} !~ /^.*Z$/;
    # $f{umiUserDateOfEmployment} .= 'Z' if exists $f{umiUserDateOfEmployment} && $f{umiUserDateOfEmployment} !~ /^.*Z$/;
    # $f{umiUserDateOfTermination} .= 'Z' if exists $f{umiUserDateOfTermination} && $f{umiUserDateOfTermination} !~ /^.*Z$/;

    $f{umiUserDateOfBirth} = $self->h_ts_to_generalizedTime($f{umiUserDateOfBirth})
      if exists $f{umiUserDateOfBirth} && $f{umiUserDateOfBirth} ne '';
    $f{umiUserDateOfEmployment} = $self->h_ts_to_generalizedTime($f{umiUserDateOfEmployment})
      if exists $f{umiUserDateOfEmployment} && $f{umiUserDateOfEmployment} ne '';
    $f{umiUserDateOfTermination} = $self->h_ts_to_generalizedTime($f{umiUserDateOfTermination})
      if exists $f{umiUserDateOfTermination} && $f{umiUserDateOfTermination} ne '';

    my $diff = $self->h_hash_diff( \%l, \%f);
    $self->h_log($diff);
    $self->h_log([keys(%l)]);
    $self->h_log([keys(%f)]);

    my ($add, $delete, $replace, $changes);

    push @$add,     jpegPhoto => $self->h_img_resize( $upload->{jpegPhoto}->slurp, $upload->{jpegPhoto}->size )
      if ! exists $from_ldap->{jpegPhoto} && exists $upload->{jpegPhoto} && $upload->{jpegPhoto}->size > 0;

    push @$replace, jpegPhoto => $self->h_img_resize( $upload->{jpegPhoto}->slurp, $upload->{jpegPhoto}->size )
      if exists $from_ldap->{jpegPhoto} && exists $upload->{jpegPhoto} && $upload->{jpegPhoto}->size > 0;

    if ( %{$diff->{added}} ) {
      push @$add, $_ => $diff->{added}->{$_} foreach (keys(%{$diff->{added}}));
    }
    if ( %{$diff->{removed}} ) {
      push @$delete, $_ => [] foreach (keys(%{$diff->{removed}}));
    }
    if ( %{$diff->{changed}} ) {
      push @$replace, $_ => $diff->{changed}->{$_}->{new} foreach (keys(%{$diff->{changed}}));
    }
    push @$changes, add => $add         if $add;
    push @$changes, delete => $delete   if $delete;
    push @$changes, replace => $replace if $replace;

    $self->h_log($changes);
    $from_form->{$tmp_k} = $tmp_v;
    $self->stash(from_form => $from_form);

    if ( $changes ) {
      my $msg = $ldap->modify($dn, $changes);
      $self->stash(debug => {$msg->{status} => [ $msg->{message} ]});
      # need this to get form updated on submit
      $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{acc_root},
		      filter => '(uid=' . $uid .')',
		      scope => 'one',
		      attrs => [qw( givenName
				    jpegPhoto
				    l
				    sn
				    title
				    umiUserCountryOfResidence
				    umiUserDateOfBirth
				    umiUserDateOfEmployment
				    umiUserDateOfTermination
				    umiUserGender )], };
      $search = $ldap->search( $search_arg );
      $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
      if ($search->count) {
	%$from_ldap = map {
	  if ( $_ eq 'mail' || $_ eq 'jpegPhoto' ) {
	    $_ => $search->entry->get_value($_);
	  } else {
	    $_ => utf8::is_utf8($search->entry->get_value($_)) ? $search->entry->get_value($_) : decode_utf8($search->entry->get_value($_));
	  }
	} $search->entry->attributes;
      }
      $self->stash(from_ldap => $from_ldap);
    }
  }
  $self->render(template => 'protected/profile/modify'); #, layout => undef);
}

sub project_new ($self) {
  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my ($search, $search_arg);
  my ($employees, $err) = $ldap->all_users;

  my $par = $self->req->params->to_hash;
  # $self->h_log($par);
  $self->stash(project_new_params => $par, employees => $employees);

  my $v = $self->validation;
  return $self->render(template => 'protected/project/new') unless $v->has_data;

  $v->required('proj_name')->check('size', 2, 50)->check('like', qr/^[A-Za-z0-9.-_]+$/);
  $v->error( proj_name   => ['Must be 2-50 charaters in length and can be only ASCII characters: A-Za-z0-9.-_'] )
    if $v->error('proj_name');
  # looks like some projects can be empty
  # $v->required('team_pm');
  # $v->required('team_back');
  # $v->required('team_front');
  # $v->required('team_devops');
  # $v->required('team_qa');
  # $v->error( team_pm     => ['Select at least one member.']) if $v->error('team_pm');
  # $v->error( team_back   => ['Select at least one member.']) if $v->error('team_back');
  # $v->error( team_front  => ['Select at least one member.']) if $v->error('team_front');
  # $v->error( team_devops => ['Select at least one member.']) if $v->error('team_devops');
  # $v->error( team_qa    => ['Select at least one mamber.'])                 if $v->error('team_qa');

  # $self->h_log($v->error);

  if ( ! $v->has_error ) {
    $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{project},
		    filter => "(cn=" . $par->{proj_name} . ")",
		    scope => "one",
		    attrs => ['cn'] };
    $search = $ldap->search( $search_arg );
    $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
    $v->error(proj_name => ['Project with such name exists']) if $search->count > 0;

    ### attribute associatedDomain is been set by admins after project object creation
    my $attrs = {
		 objectClass => $self->{app}->{cfg}->{ldap}->{objectClass}->{project},
		 ### FIX proj_name must comply regex ^[A-Za-z0-9.-_]+$
		 cn => lc $par->{proj_name},
		 description => $par->{proj_descr},
		 associatedDomain => 'unknown'
		};

    $self->h_log($attrs);

    my $msg = $ldap->add(sprintf("cn=%s,%s",
				 lc $par->{proj_name},
				 $self->{app}->{cfg}->{ldap}->{base}->{project}),
			 $attrs);
    my $debug;
    push @{$debug->{$msg->{status}}}, $msg->{message};
    my @groups = keys %{$self->{app}->{cfg}->{ui}->{project}->{team}->{roles}};
    foreach my $g (@groups) {
      ### FIX proj_name must comply regex ^[A-Za-z0-9.-_]+$
      $attrs = {
		objectClass => $self->{app}->{cfg}->{ldap}->{objectClass}->{project_groups},
		cn => sprintf("%s_%s", lc $par->{proj_name}, $g),
		memberUid => $par->{$g}
	       };
      my $gn = $ldap->last_num($self->{app}->{cfg}->{ldap}->{base}->{project_groups}, '(cn=*)', 'gidNumber');
      if ( $gn->[1] ) {
	$self->h_log($gn->[1]);
	$attrs->{gidNumber} = undef;
      } else {
	$attrs->{gidNumber} = $gn->[0] + 1;
      }
      $self->h_log($attrs);

      $msg = $ldap->add(sprintf("cn=%s,%s",
				sprintf("%s_%s", lc $par->{proj_name}, $g),
				$self->{app}->{cfg}->{ldap}->{base}->{project_groups}),
			$attrs);
      push @{$debug->{$msg->{status}}}, $msg->{message};
    }
    $self->h_log($debug);
    $self->stash(debug => $debug);
  }

  $self->render(template => 'protected/project/new'); #, layout => undef);
}

sub project_modify ($self) {
  my $from_form = $self->req->params->to_hash;
  my $debug;
  #$self->h_log($from_form);

  my $proj = $self->stash->{proj} // $from_form->{proj_to_modify} // '';
  $from_form->{proj_to_modify} = $self->stash->{proj} if exists $self->stash->{proj};
  #$self->h_log($from_form);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  ### PROJECT OBJECT
  my $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{project},
		     filter => '(cn=' . $proj .')',
		     scope => 'one',
		     attrs => [qw(cn description)]};
  my $search = $ldap->search( $search_arg );
  $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  my $from_ldap;
  if ($search->count) {
    %{$from_ldap->{proj}->{obj}} =
      map { $_ => ref($search->entry->get_value($_)) eq 'ARRAY' ? [$search->entry->get_value($_)] : $search->entry->get_value($_) }
      $search->entry->attributes;
    $from_ldap->{proj}->{dn} = $search->entry->dn;
  }

  ### PROJECT GROUPS
  $from_ldap->{groups} = {};
  $search_arg = { base => sprintf("ou=group,%s", $self->{app}->{cfg}->{ldap}->{base}->{project}),
		  filter => '(cn=' . $proj . '*)', };
  $search = $ldap->search( $search_arg );
  $self->{app}->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  $from_ldap->{groups}->{$_->get_value('cn')} = $_->get_value('memberUid', asref => 1)
    foreach ($search->entries);

  ### EMPLOYEES:TEAM MEMBERS SELECT ELEMENTS
  $search_arg =
    { base => $self->{app}->{cfg}->{ldap}->{base}->{acc_root},
      filter => sprintf("(&(uid=*)(!(gidNumber=%s)))",
			$self->{app}->{cfg}->{ldap}->{defaults}->{group}->{blocked}->{gidnumber}),
      scope => "one",
      attrs => [qw(uid givenName sn)] };
  $search = $ldap->search( $search_arg );
  $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  my $e_str = $search->as_struct;
  my ($team, $employees, $employees_sorted);
  foreach my $g (keys(%{$from_ldap->{groups}})) {
    foreach my $k (keys(%$e_str)) {
      next if ! exists $e_str->{$k}->{givenname} || ! exists $e_str->{$k}->{sn};
      my $gecos = $e_str->{$k}->{sn}->[0] . " " . $e_str->{$k}->{givenname}->[0];
      utf8::decode($gecos) unless utf8::is_utf8($gecos);
      if ( grep {$e_str->{$k}->{uid}->[0] eq $_} @{$from_ldap->{groups}->{$g}} ) {
	push @$team, [ $gecos => $e_str->{$k}->{uid}->[0], selected => 'selected' ];
      } else {
	push @$team, [ $gecos => $e_str->{$k}->{uid}->[0] ];
      }
    }
    @{$from_ldap->{employees}->{$g}} = sort {$a->[0] cmp $b->[0]} @$team;
    $team = undef;
  }

  foreach my $k (keys(%$e_str)) {
    next if ! exists $e_str->{$k}->{givenname} || ! exists $e_str->{$k}->{sn};
    push @$team, [ $e_str->{$k}->{sn}->[0] . " " . $e_str->{$k}->{givenname}->[0] => $e_str->{$k}->{uid}->[0] ];
  }
  @{$from_ldap->{employees}->{asis}} = sort {$a->[0] cmp $b->[0]} @$team;

  ### REST

  #$self->h_log($from_ldap->{groups});
  $self->stash(from_ldap => $from_ldap);

  $self->h_log($from_form);
  $self->stash(from_form => $from_form);

  $self->stash( proj => $self->stash->{proj},
		from_ldap => $self->stash->{from_ldap},
		project_team_roles => [ keys %{$self->{app}->{cfg}->{ui}->{project}->{team}->{roles}} ] );

  my $v = $self->validation;
  return $self->render(template => 'protected/project/modify') unless $v->has_data;

  my $re = qr/^[a-z0-9_.\-]+$/;
  $v->required('cn')->size(1, 50)->like($re);

  my ($msg, $diff, $add, $delete, $replace, $changes, $chg);
  $diff = $self->h_hash_diff( $from_ldap->{proj}->{obj},
			      { cn => $from_form->{cn},
				description => $from_form->{description} } );
  #$self->h_log($diff);
  if ( %{$diff->{added}} ) {
    push @$add, $_ => $diff->{added}->{$_} foreach (keys(%{$diff->{added}}));
    push @$changes, add => $add;
  }
  if ( %{$diff->{removed}} ) {
    push @$delete, $_ => [] foreach (keys(%{$diff->{removed}}));
    push @$changes, delete => $delete;
  }
  if ( %{$diff->{changed}} ) {
    push @$replace, $_ => $diff->{changed}->{$_}->{new} foreach (keys(%{$diff->{changed}}));
    push @$changes, replace => $replace;
  }

  if (defined $changes) {
    $msg = $ldap->modify($from_ldap->{proj}->{dn}, $changes);
    ### !!! to push to debug_message rather than overwrite
    push @{$debug->{$msg->{status}}}, $msg->{message};
    $chg->{proj} = $changes;
  }
  $diff = $add = $delete = $replace = $changes = undef;

  # $self->h_log($self->{app}->{cfg}->{ui}->{project}->{team}->{roles});

  foreach my $team_role ( @{[ keys %{$self->{app}->{cfg}->{ui}->{project}->{team}->{roles}} ]} ) {
    my $ldap_group_name = $from_ldap->{proj}->{obj}->{cn} . '_' . $team_role;
    if ( ! exists $from_form->{$team_role} && ! exists $from_ldap->{groups}->{ $ldap_group_name } ) {
      next;
    } elsif ( ! exists $from_form->{$team_role} && exists $from_ldap->{groups}->{ $ldap_group_name } ) {
      push @$changes, delete => [memberUid => []];
    } elsif ( exists $from_form->{$team_role} && ! exists $from_ldap->{groups}->{ $ldap_group_name } ) {
      push @$changes, add =>
	[ memberUid => ref($from_form->{$team_role}) ne 'ARRAY' ? [ $from_form->{$team_role} ] : $from_form->{$team_role} ];
    } else {
      # $self->h_log($from_ldap->{groups}->{ $ldap_group_name });
      # $self->h_log($from_form->{$team_role});
      $diff = $self
	->h_array_diff( $from_ldap->{groups}->{ $ldap_group_name },
			ref($from_form->{$team_role}) ne 'ARRAY' ? [$from_form->{$team_role}] : $from_form->{$team_role});
      $self->h_log($diff);
      if ( @{$diff->{added}} ) {
	push @$add, memberUid => $diff->{added};
	push @$changes, add => $add;
      }
      if ( @{$diff->{removed}} ) {
	push @$delete, memberUid => [];
	push @$changes, delete => $delete;
      }
    }

    if (defined $changes) {
      $msg = $ldap->modify(sprintf("cn=%s,%s",
				   $ldap_group_name,
				   $self->{app}->{cfg}->{ldap}->{base}->{project_groups}),
			   $changes);
      ### !!! to push to debug_message rather than overwrite
      push @{$debug->{$msg->{status}}}, $msg->{message};
      $chg->{group}->{$team_role} = $changes if defined $changes;;
    }
    $diff = $add = $delete = $replace = $changes = undef;
  }
  $self->h_log($chg);

  $self->render(template => 'protected/project/modify', debug => $debug); # , layout => undef);
}

sub resolve ($self) {
  my $p = $self->req->params->to_hash;
  my $a = { query => { A   => $p->{a}   // '',
		       PTR => $p->{ptr} // '',
		       MX  => $p->{mx}  // '', }, };

  my $res;
  while ( my($k, $v) = each %{$a->{query}} ) {
    next if $v eq '';
    $res = ref($v) eq 'ARRAY' ? $v : [ $v ];

    push @{$a->{reply}}, $self->h_dns_resolver({ type  => $k,
						 debug => 0,
						 name  => $_ })
      foreach (@{$res});
  }

  foreach (@{$a->{reply}}) {
    push @{$a->{body}}, $_->{success}         if exists $_->{success};
    push @{$a->{body}}, $_->{error}->{errstr} if exists $_->{error};
  }

  # $self->h_log($_) foreach (@{$a->{body}});

  $self->render( #template => 'protected/tool/resolv',
		 layout => undef,
		 text => join("\n", @{$a->{body}}) // '' );
}

=head1 moddn

Rename the entry given by "DN" on the server.

=cut

sub moddn ($self) {

  my $par = $self->req->params->to_hash;
  # $self->h_log($par);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $msg = $ldap->moddn($par);
  $self->session( debug => $msg );

  ### alas, this redirect by nature performs a GET request
  return $self
    ->redirect_to($self->url_for('search_common')
		  ->query( search_base_case => $par->{search_base_case},
			   search_filter => $par->{search_filter},
			   ldap_subtree => $par->{ldap_subtree} )
		 );
}

sub groups ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);

  return $self->render(template => 'protected/home') unless exists $p->{dn_to_group};

  if ( exists $p->{group} ) {
    $p->{group} = ref($p->{group}) eq 'ARRAY' ? $p->{group} : [ $p->{group} ];
  }
  $self->h_log($self->h_get_rdn_val($p->{dn_to_group}));
  $self->stash( dn_to_group => $p->{dn_to_group} );

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );

  #--- BEFORE SUBMIT start --------------------------------------
  my $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{group},
		     filter => '(memberUid=' . $self->h_get_rdn_val($p->{dn_to_group}) .')',};
  my $search = $ldap->search( $search_arg );
  $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;

  my %u = map { $_->get_value('cn') => 1 } $search->entries;

  $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{group}, scope => 'one' };
  $search = $ldap->search( $search_arg );
  $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;
  my @group_names = $search->sorted('cn');

  my @e = map {
    exists $u{$_->get_value('cn')} ?
      [ $_->get_value('cn') => $_->get_value('cn'), selected => 'selected'] :
      $_->get_value('cn')
    } @group_names;

  my @o = keys(%u);
  my $diff = $self->h_array_diff(\@o,$p->{group});
  $self->h_log($diff);
  #--- BEFORE SUBMIT stop ---------------------------------------

  my ($debug, $msg);
  #if ( exists $p->{group} ) {
    foreach (@{$diff->{added}}) {
      $msg = $ldap->modify( sprintf('cn=%s,%s',$_, $self->{app}->{cfg}->{ldap}->{base}->{group}),
			    [ add => [ memberUid => $self->h_get_rdn_val($p->{dn_to_group}) ]] );
      $self->h_log( $msg->{message} ) if $msg->{status} eq 'error';
      push @{$debug->{$msg->{status}}}, $msg->{message};
    }
    foreach (@{$diff->{removed}}) {
      $msg = $ldap->modify( sprintf('cn=%s,%s',$_, $self->{app}->{cfg}->{ldap}->{base}->{group}),
			    [ delete => [ memberUid => $self->h_get_rdn_val($p->{dn_to_group}) ]] );
      $self->h_log( $msg->{message} ) if $msg->{status} eq 'error';
      push @{$debug->{$msg->{status}}}, $msg->{message};
    }
  #}

  #--- AFTER SUBMIT start --------------------------------------
  $search_arg = { base => $self->{app}->{cfg}->{ldap}->{base}->{group},
		  filter => '(memberUid=' . $self->h_get_rdn_val($p->{dn_to_group}) .')',};
  $search = $ldap->search( $search_arg );
  $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code;

  %u = map { $_->get_value('cn') => 1 } $search->entries;

  @e = map {
    exists $u{$_->get_value('cn')} ?
      [ $_->get_value('cn') => $_->get_value('cn'), selected => 'selected'] :
      $_->get_value('cn')
    } @group_names;

  #--- AFTER SUBMIT stop ---------------------------------------

  $self->stash( select_options => \@e, debug => $debug );
  $self->render(template => 'protected/profile/groups');
}

sub onboarding ($self) {
  my $p = $self->req->params->to_hash;
  $self->h_log($p);
  $self->stash( dn_to_onboard => $p->{dn_to_onboard} );

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my $search_arg = { base => $p->{dn_to_onboard}, scope => 'base', };
  my $search = $ldap->search( $search_arg );
  $self->h_log( $self->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != LDAP_NO_SUCH_OBJECT;
  my $root = $search->entry;

  my $v = $self->validation;

  my (%debug, $service);
  my $svcs = $self->{app}->{cfg}->{ui}->{onboarding}->{services};
  # $self->h_log($svcs);
  foreach my $svc (keys %$svcs) {
    foreach my $d (@{$svcs->{$svc}->{fqdn}}) {
      $search_arg = { base => sprintf('authorizedService=%s@%s,%s', $svcs->{$svc}->{svc}, $d, $self->session->{user_obj}->{dn}),
		      scope => 'one' };
      # $self->h_log($search_arg);
      $search = $ldap->search( $search_arg );
      $self->h_log( $self->{app}->h_ldap_err($search, $search_arg) ) if $search->code && $search->code != LDAP_NO_SUCH_OBJECT;
      if ($search->code && $search->code == LDAP_NO_SUCH_OBJECT) {
	$service->{$svc}->{exists} = 0;
	push @{$debug{ok}}, sprintf("You don't have account for service <mark>%s</mark>, will be created", $svc)
	  if ! $v->has_data;
      } else {
	foreach my $e ($search->entries) {
	  $service->{$svc}->{exists} = 1;
	  push @{$service->{$svc}->{acc}}, $e;
	  push @{$debug{warn}}, sprintf("Service <mark>%s</mark> account, login: <mark>%s</mark>, exists (created on %s)",
					$svc, $e->get_value('uid'), $e->get_value('createTimestamp'))
	    if ! $v->has_data;
	}
      }
    }
  }
  # $self->h_log($service);

  $self->stash( debug => \%debug );

  return $self->render(template => 'protected/profile/onboarding') unless $v->has_data;

  $self->stash( is_submited => 1 );

  my ($svc_details, $br, $s);
  my $dry_run = 0;

  my $k_ssh = $self->h_keygen_ssh;
  # $self->stash(debug => $k_ssh->{debug});

  my $k_gpg = $self->h_keygen_gpg({ name =>
				    { real  => sprintf("%s %s",
						       $self->session->{user_obj}->{givenname},
						       $self->session->{user_obj}->{sn}) // "name is absent",
				      email => $self->session->{user_obj}->{mail} // "mail is absent" }});
  # $self->stash(debug => $k_gpg->{debug});

  my ($mesg, $op_dn, $op_attrs);
  if ( $dry_run == 0 && exists $k_gpg->{send_key} ) {
    $op_dn = sprintf("pgpCertID=%s,%s",
		     $k_gpg->{send_key}->{pgpCertID},
		     $self->{app}->{cfg}->{ldap}->{base}->{pgp});
    %{$op_attrs} = map { $_ => $k_gpg->{send_key}->{$_} } keys %{$k_gpg->{send_key}};
    #$self->h_log($add_dn);
    #$self->h_log($add_attrs);
    $mesg = $ldap->add( $op_dn, $op_attrs );
    push @{$debug{$mesg->{status}}}, $mesg->{message};
  }

  foreach my $svc (keys %$service) {
    # next if $service->{$svc}->{exists} == 1;

    $p->{authorizedService} = $svcs->{$svc}->{svc};
    $p->{sshKeyText} = $k_ssh->{public} if $svc eq 'ssh-acc';

    foreach my $d (@{$svcs->{$svc}->{fqdn}}) {
      $p->{associatedDomain} = $d;
      if ( $service->{$svc}->{exists} == 0 ) {
	$br = $self->h_branch_add_if_not_exists($p, $ldap, $root, \%debug, $dry_run);
	$s = $self->h_service_add_if_not_exists($p, $ldap, $root, $br, \%debug, $dry_run);
	push @{$svc_details->{$svc}->{added}}, { fqdn => $d, svc_details => $s->{svc_details} };
      } elsif ( $svc eq 'ssh-acc' ) {
	$op_dn = sprintf('uid=%s,authorizedService=%s@%s,%s',
			 lc(sprintf("%s.%s", $self->session->{user_obj}->{givenname}, $self->session->{user_obj}->{sn})),
			 $svc,
			 $d,
			 $self->session->{user_obj}->{dn});
	$op_attrs = [ add => [ sshPublicKey => $k_ssh->{public} ] ];
	#$self->h_log($add_dn);
	#$self->h_log($add_attrs);
	$mesg = $ldap->modify( $op_dn, $op_attrs );
	push @{$debug{$mesg->{status}}}, $mesg->{message};
      }
    }

    $svc_details->{$svc}->{exists} = $service->{$svc}->{exists} == 1 ? 1 : 0;
  }

  my $root_pwd = $self->h_pwdgen;
  $mesg = $ldap->modify( $self->session->{user_obj}->{dn},
			 [ replace => [ userPassword => $root_pwd->{ssha} ] ] );
  push @{$debug{$mesg->{status}}}, $mesg->{message};

  # $self->h_log($k_ssh);
  # $self->h_log(\%debug);
  delete $debug{ok};
  delete $service->{$_}->{acc} foreach (keys %$service);

  $self->stash( debug => \%debug,
		root_pwd => $root_pwd->{clear},
		svc_added => $svc_details,
		k_gpg => $k_gpg,
		k_ssh => $k_ssh );

  $self->render(template => 'protected/profile/onboarding');
}

sub sargon ($self) {
  my (%debug, $p);
  $p = $self->req->params->to_hash;
  $self->h_log($p);
  foreach (keys %$p) {
     if ( $p->{$_} eq '' ) {
       delete $p->{$_};
     } elsif (ref($p->{$_}) eq 'ARRAY') {
       @{$p->{$_}} = grep { $_ ne "" } @{$p->{$_}};
     }
  }
  $self->h_log($p);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my %schema_all_attributes = map { $_->{name} => $_ } $ldap->schema->all_attributes;

  my ($sargonUser, $groups, $sargonHost, $err);
  ($sargonUser, $err) = $ldap->all_users;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;
  undef $err;
  ($groups, $err) = $ldap->all_groups;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;
  undef $err;
  ($sargonHost, $err) = $ldap->all_hosts;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;

  $p->{sargonMount} = [$p->{sargonMount}] if exists $p->{sargonMount} && ref($p->{sargonMount}) ne 'ARRAY';
  $p->{sargonMount} = [''] if ! exists $p->{sargonMount};

  $self->stash(
	       sargonUser => $sargonUser,
	       groups => $groups,
	       sargonHost => $sargonHost,
	       sargonMount => $p->{sargonMount},
	       schema => \%schema_all_attributes,
	       debug => \%debug,
	      );

  my $v = $self->validation;
  return $self->render(template => 'protected/sargon/new') unless $v->has_data;

  my $re_cn = qr/^[[:alnum:]_-]+$/;
  $v->required('cn')->like($re_cn);
  $v->error( cn => ['ASCII alnum, - and _ characters only'] ) if $v->error('cn');

  if ( ! $v->has_error ) {
    my $attrs;
    $attrs->{$_} = $p->{$_} foreach keys %$p;
    $attrs->{objectClass} = $self->{app}->{cfg}->{ldap}->{objectClass}->{sargon};

    if ( exists $attrs->{groups} ) {
      my @g = map { '+'.$_ } @{$attrs->{groups}};
      $attrs->{sargonUser} = [ @{$attrs->{sargonUser}}, @g ];
      delete $attrs->{groups};
    }
    if ( exists $attrs->{sargonAllowPrivileged} ) {
      $attrs->{sargonAllowPrivileged} = $attrs->{sargonAllowPrivileged} eq 'on' ? 'TRUE' : 'FALSE';
    }
    $attrs->{sargonNotBefore} .= 'Z' if exists $attrs->{sargonNotBefore};
    $attrs->{sargonNotAfter} .= 'Z' if exists $attrs->{sargonNotAfter};
    $self->h_log($attrs);

    my $msg = $ldap->add(sprintf("cn=%s,%s", $attrs->{cn}, $self->{app}->{cfg}->{ldap}->{base}->{sargon}),
			 $attrs);
    push @{$debug{$msg->{status}}}, $msg->{message};
  }

  $self->stash( debug => \%debug, schema => \%schema_all_attributes );
  $self->render(template => 'protected/sargon/new');

}

=head1 sudo

https://www.sudo.ws/docs/man/sudoers.ldap.man/

=cut

sub sudo ($self) {
  my (%debug, $p);
  $p = $self->req->params->to_hash;
  $self->h_log($p);
  foreach (keys %$p) {
     if ( $p->{$_} eq '' ) {
       delete $p->{$_};
     } elsif (ref($p->{$_}) eq 'ARRAY') {
       @{$p->{$_}} = grep { $_ ne "" } @{$p->{$_}};
     }
  }
  $self->h_log($p);

  my $ldap = Umi::Ldap->new( $self->{app}, $self->session('uid'), $self->session('pwd') );
  my %schema_all_attributes = map { $_->{name} => $_ } $ldap->schema->all_attributes;

  my ($msg, $sudoUser, $groups, $sudoHost, $err);
  ($sudoUser, $err) = $ldap->all_users;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;
  undef $err;
  unshift @$sudoUser, '', 'ALL';
  ($groups, $err) = $ldap->all_groups;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;
  undef $err;
  unshift @$groups, '', 'ALL';
  ($sudoHost, $err) = $ldap->all_hosts;
  push @{$debug{$err->{status}}}, $err->{message} if defined $err;
  unshift @$sudoHost, '', 'ALL';

  $p->{sudoCommand} = [$p->{sudoCommand}] if exists $p->{sudoCommand} && ref($p->{sudoCommand}) ne 'ARRAY';
  $p->{sudoCommand} = [''] if ! exists $p->{sudoCommand};

  $p->{sudoOption} = [$p->{sudoOption}] if exists $p->{sudoOption} && ref($p->{sudoOption}) ne 'ARRAY';
  $p->{sudoOption} = [''] if ! exists $p->{sudoOption};

  $self->stash(
	       sudoUser => $sudoUser,
	       groups => $groups,
	       sudoHost => $sudoHost,
	       sudoCommand => $p->{sudoCommand},
	       sudoOption => $p->{sudoOption},
	       schema => \%schema_all_attributes,
	       debug => \%debug,
	      );

  my $v = $self->validation;
  return $self->render(template => 'protected/sudo/new') unless $v->has_data;
  my $re_cn = qr/^[[:alnum:]_-]+$/;
  $v->required('cn')->like($re_cn);
  $v->error( cn => ['ASCII alnum, - and _ characters only'] ) if $v->error('cn');
  $v->error( sudoUser => ['user or group are mandatory'] ) if ! exists $p->{sudoUser} && ! exists $p->{groups};
  $v->error( groups => ['user or group are mandatory'] ) if ! exists $p->{sudoUser} && ! exists $p->{groups};

  if ( ! $v->has_error ) {
    my $attrs;
    $attrs->{$_} = $p->{$_} foreach keys %$p;
    $attrs->{objectClass} = $self->{app}->{cfg}->{ldap}->{objectClass}->{sudo};

    if ( exists $attrs->{groups} ) {
      $attrs->{sudoUser} = '%' . $attrs->{groups};
      delete $attrs->{groups};
    }
    $self->h_log($attrs);

    # $msg = $ldap->add(sprintf("cn=%s,%s", $attrs->{cn}, $self->{app}->{cfg}->{ldap}->{base}->{sargon}),
    #			 $attrs);
    $self->stash(attrs => $attrs);
    push @{$debug{$msg->{status}}}, $msg->{message};
  }

  $self->stash( debug => \%debug, schema => \%schema_all_attributes );
  $self->render(template => 'protected/sudo/new');
}

1;
